<!DOCTYPE html>
<html lang="uz">
<head>
    <meta charset="UTF-8">
    <title>JOKKER</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <style>
        body { margin: 0; padding: 0; background-color: #000; overflow: hidden; }
        canvas { 
            display: block; 
            transform: scaleX(-1); 
            width: 100vw; 
            height: 100vh; 
            object-fit: cover;
        }
        video { display: none; }
    </style>
</head>
<body>

<video id="input_video"></video>
<canvas id="output_canvas"></canvas>

<script>
    const videoElement = document.getElementById('input_video');
    const canvasElement = document.getElementById('output_canvas');
    const canvasCtx = canvasElement.getContext('2d');

    function resizeCanvas() {
        canvasElement.width = window.innerWidth;
        canvasElement.height = window.innerHeight;
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    let balls = [];
    let gridMap = {}; 


    const GRID_SIZE = 35;
    const PINCH_THRESHOLD = 0.05; 
    const FIST_THRESHOLD = 0.25;  

    
    function getJokkerColor() {
        const palette = [
            '#FFFFFF', '#FFFFFF',
            '#FF0000',
            '#00FFFF',
            'rgb(255 452 456)',
            '#0000FF',
            'rgb(0, 255, 255)',
            'rgb(197 203 38)',
        ];
        return palette[Math.floor(Math.random() * palette.length)];
    }

    const hands = new Hands({locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
    }});

    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.7,
        minTrackingConfidence: 0.7
    });

    hands.onResults(onResults);

    const camera = new Camera(videoElement, {
        onFrame: async () => { await hands.send({image: videoElement}); },
        width: 1920,
        height: 1080
    });
    camera.start();

    function onResults(results) {
        canvasCtx.fillStyle = '#000000';
        canvasCtx.fillRect(0, 0, canvasElement.width, canvasElement.height);

        drawAnimatedBalls();

 
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const landmarks = results.multiHandLandmarks[0];
            
            drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: 'rgb(0, 255, 255)', lineWidth: 5});
            drawLandmarks(canvasCtx, landmarks, {color: '#FFFFFF', lineWidth: 2, radius: 6});

            const indexTip = landmarks[8];
            const thumbTip = landmarks[4];
            
           
            const x = indexTip.x * canvasElement.width;
            const y = indexTip.y * canvasElement.height;

           
            const wrist = landmarks[0];
            const middleTip = landmarks[12];
            const distMiddle = Math.hypot(middleTip.x - wrist.x, middleTip.y - wrist.y);
            
            if (distMiddle < FIST_THRESHOLD) {
                balls = [];     
                gridMap = {};   
                return; 
            } 
            
           
            const pinchDist = Math.hypot(indexTip.x - thumbTip.x, indexTip.y - thumbTip.y);

            if (pinchDist < PINCH_THRESHOLD) {
                
                canvasCtx.beginPath();
                canvasCtx.arc(x, y, 5, 0, 2 * Math.PI);
                canvasCtx.fillStyle = '#FFFFFF';
                canvasCtx.fill();

                
                const col = Math.floor(x / GRID_SIZE);
                const row = Math.floor(y / GRID_SIZE);
                const key = `${col},${row}`;

                if (!gridMap[key]) {
                    
                    const centerX = col * GRID_SIZE + (GRID_SIZE / 2);
                    const centerY = row * GRID_SIZE + (GRID_SIZE / 2);

                    addBall(centerX, centerY, key);
                }
            }
        }
    }

    function addBall(x, y, key) {
        balls.push({
            x: x,
            y: y,
            key: key,
            color: getJokkerColor(),
            timeOffset: Date.now()
        });
        gridMap[key] = true;

        
        if (balls.length > 600) {
            const removedBall = balls.shift();
            if (removedBall) delete gridMap[removedBall.key];
        }
    }

    function drawAnimatedBalls() {
        const time = Date.now() * 0.003;
        
        
        const baseRadius = (GRID_SIZE / 2) - 2; 

        balls.forEach(ball => {
           
            const scale = 1 + Math.sin(time + ball.x * 0.05 + ball.y * 0.05) * 0.15;
            const radius = baseRadius * scale; 

            canvasCtx.beginPath();
            const gradient = canvasCtx.createRadialGradient(
                ball.x, ball.y, radius * 0.1, 
                ball.x, ball.y, radius
            );
            gradient.addColorStop(0, '#FFFFFF');
            gradient.addColorStop(0.5, ball.color);
            gradient.addColorStop(1, 'rgba(0,0,0,0)');

            canvasCtx.fillStyle = gradient;
            canvasCtx.arc(ball.x, ball.y, radius, 0, Math.PI * 2);
            canvasCtx.fill();
        });
    }

    window.addEventListener('resize', () => {
        resizeCanvas();
        balls = [];
        gridMap = {};
    });

</script>

</body>
</html>
