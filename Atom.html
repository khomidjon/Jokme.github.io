<!DOCTYPE html>
<html lang="uz">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Atom</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: 'Segoe UI', sans-serif; color: #fff; }
        
        /* Intro Screen */
        #intro-screen {
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            background: #000; z-index: 9999; display: flex;
            justify-content: center; align-items: center; transition: opacity 1s ease-out;
        }
        .intro-content { display: flex; align-items: center; gap: 30px; }
        #edge-logo { width: 120px; animation: spinIn 1.5s forwards, glowBlue 2s infinite alternate; }
        #intro-text { font-size: 50px; font-weight: bold; color: #00d2ff; text-shadow: 0 0 15px #00d2ff; opacity: 0; transform: translateX(-50px); animation: slideInText 1s forwards 1.2s; }

        @keyframes spinIn { 0% { transform: rotate(0deg) scale(0); opacity: 0; } 100% { transform: rotate(720deg) scale(1); opacity: 1; } }
        @keyframes slideInText { to { opacity: 1; transform: translateX(0); } }
        @keyframes glowBlue { 0% { filter: drop-shadow(0 0 5px #00d2ff); } 100% { filter: drop-shadow(0 0 20px #00d2ff); } }

        /* UI Elements */
        .glass-back-btn {
            position: fixed; top: 25px; left: 25px; padding: 12px 25px;
            text-decoration: none; color: white; z-index: 10001;
            background: rgba(255, 255, 255, 0.1); backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 20px;
        }
        
        .settings-panel {
            position: fixed; top: 25px; right: 25px; z-index: 10001;
            background: rgba(255, 255, 255, 0.1); backdrop-filter: blur(10px);
            padding: 15px; border-radius: 20px; border: 1px solid rgba(255, 255, 255, 0.2);
        }

        #ui_overlay {
            position: absolute; bottom: 20px; right: 20px;
            width: 240px; height: 180px; border: 1px solid #00d2ff;
            background: rgba(0, 210, 255, 0.1); border-radius: 10px; transform: scaleX(-1);
        }
        #input_video { display: none; }
    </style>
</head>
<body>

    <a href="dashboard.html" class="glass-back-btn">â€¹ Orqaga</a>

    <div class="settings-panel">
        <label>Atom: <span id="count-val">5000</span></label><br>
        <input type="range" id="particle-count" min="500" max="50000" step="500" value="50000">
    </div>

    <div id="intro-screen">
        <div class="intro-content">
            <img src="https://upload.wikimedia.org/wikipedia/commons/9/98/Microsoft_Edge_logo_%282019%29.svg" alt="Logo" id="edge-logo">
            <h1 id="intro-text">Homidjon Coding...</h1>
        </div>
    </div>

    <video id="input_video" playsinline muted></video>
    <canvas id="ui_overlay"></canvas>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // Global variables
        let count = 5000;
        let scene, camera, renderer, particles, geometry;
        const shapes = { scatter: [], sphere: [], heart: [], torus: [] };
        let currentColor = new THREE.Color(0x00d2ff);

        const videoElement = document.getElementById('input_video');
        const uiCanvas = document.getElementById('ui_overlay');
        const uiCtx = uiCanvas.getContext('2d');
        const slider = document.getElementById('particle-count');
        const countDisplay = document.getElementById('count-val');

        // 1. Intro Logic
        setTimeout(() => {
            const intro = document.getElementById('intro-screen');
            intro.style.opacity = '0';
            setTimeout(() => intro.remove(), 1000);
        }, 5000);

        // 2. Atom Generator (To'g'rilangan sikl bilan)
        function createPointsData(newCount) {
            shapes.scatter = []; shapes.sphere = []; shapes.heart = []; shapes.torus = [];
    
            for (let i = 0; i < newCount; i++) {
        // Scatter (tarqoq)
                shapes.scatter.push((Math.random() - 0.5) * 20, (Math.random() - 0.5) * 20, (Math.random() - 0.5) * 20);
        
        // Sphere (sharik)
                const phi = Math.acos(-1 + (2 * i) / newCount);
                const theta = Math.sqrt(newCount * Math.PI) * phi;
                        shapes.sphere.push(3.5 * Math.cos(theta) * Math.sin(phi), 3.5 * Math.sin(theta) * Math.sin(phi), 3.5 * Math.cos(phi));

        // Heart (yurak)
                const t = Math.random() * Math.PI * 2;
                shapes.heart.push(
                    (16 * Math.pow(Math.sin(t), 3)) * 0.25, 
                    (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t)) * 0.25, 
                    (Math.random() - 0.5)
                );

        // Torus (donut)
                const u = Math.random() * Math.PI * 2, v = Math.random() * Math.PI * 2;
                shapes.torus.push((4 + 1.5 * Math.cos(v)) * Math.cos(u), (4 + 1.5 * Math.cos(v)) * Math.sin(u), 1.5 * Math.sin(v));
            }
        }

        function initThree() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 12;

            renderer = new THREE.WebGLRenderer({ antialias: false, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            createPointsData(count);
            geometry = new THREE.BufferGeometry();
            updateGeometry();

            const mat = new THREE.PointsMaterial({
                size: 0.06, color: 0x00d2ff, transparent: true,
                blending: THREE.AdditiveBlending, depthWrite: false
            });

            particles = new THREE.Points(geometry, mat);
            scene.add(particles);
        }

        function updateGeometry() {
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(shapes.scatter, 3));
        }

        // 3. Slider Logic
        slider.oninput = function() {
            count = parseInt(this.value);
            countDisplay.textContent = count;
            createPointsData(count);
            updateGeometry();
        };

        // 4. Hand Tracking Logic
        function onResults(results) {
            uiCtx.save();
            uiCtx.clearRect(0, 0, uiCanvas.width, uiCanvas.height);
            if (results.multiHandLandmarks) {
                for (const landmarks of results.multiHandLandmarks) {
                    drawConnectors(uiCtx, landmarks, HAND_CONNECTIONS, {color: '#00d2ff', lineWidth: 2});
                    drawLandmarks(uiCtx, landmarks, {color: '#ffffff', radius: 1});
                }
                handleLogic(results.multiHandLandmarks);
            }
            uiCtx.restore();
        }

        function handleLogic(hands) {
            const posAttr = geometry.attributes.position;
            let target = shapes.scatter;
    
            if (hands.length === 2) {
                const d = Math.hypot(hands[0][9].x - hands[1][9].x, hands[0][9].y - hands[1][9].y);
                const s = d * 12; 
                particles.scale.lerp(new THREE.Vector3(s, s, s), 0.1);
            }

            hands.forEach(hand => {
                const pinchDist = Math.hypot(hand[4].x - hand[8].x, hand[4].y - hand[8].y);
                if (pinchDist < 0.05) {
                    currentColor.setHSL(Math.random(), 0.9, 0.6);
                }
        
                let f = 0;
                [8, 12, 16, 20].forEach(idx => { if(hand[idx].y < hand[idx-2].y) f++; });
        
                if (f === 1) target = shapes.sphere;
                else if (f === 2) target = shapes.heart;
                else if (f >= 3) target = shapes.torus;
            });

            for (let i = 0; i < posAttr.array.length; i++) {
                if (target[i] !== undefined) {
                    posAttr.array[i] += (target[i] - posAttr.array[i]) * 0.12;
                }
            }
    
            posAttr.needsUpdate = true;
            particles.material.color.lerp(currentColor, 0.1); // Rang silliq o'zgarishi uchun
            particles.rotation.y += 0.005;
        }

        const handsTracker = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        handsTracker.setOptions({ maxNumHands: 2, modelComplexity: 0, minDetectionConfidence: 0.5 });
        handsTracker.onResults(onResults);

        const cam = new Camera(videoElement, {
            onFrame: async () => { await handsTracker.send({image: videoElement}); },
            width: 640, height: 480
        });
        cam.start();

        initThree();
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        if (slider) {
            slider.oninput = function() {
                count = parseInt(this.value);
                countDisplay.textContent = count;
        
                createPointsData(count); 
        
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(shapes.scatter, 3));
            };
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
